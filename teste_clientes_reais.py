#!/usr/bin/env python3
"""
Teste com Clientes Reais: Task 4 (GeminiLiveClient) + Task 3 (HomeAssistantClient)
"""

import asyncio
import os
from dotenv import load_dotenv

# Usar os clientes reais do projeto
from backend.poc_app.gemini_client.live_client import GeminiLiveClient
from backend.poc_app.gemini_client import HomeAssistantFunctionHandler, HA_FUNCTION_DECLARATIONS
from backend.poc_app.ha_client import HomeAssistantClient

async def test_real_clients():
    print("üöÄ TESTE COM CLIENTES REAIS")
    print("Task 4 (GeminiLiveClient) + Task 3 (HomeAssistantClient)")
    print("=" * 70)
    
    # Carregar vari√°veis de ambiente
    load_dotenv()
    load_dotenv("backend/.env")
    
    gemini_key = os.getenv('GOOGLE_API_KEY')
    ha_url = os.getenv('HA_URL')
    ha_token = os.getenv('HA_LLAT')
    
    print(f"‚úÖ GOOGLE_API_KEY: {'Encontrada' if gemini_key else 'N√£o encontrada'}")
    print(f"‚úÖ HA_URL: {ha_url}")
    print(f"‚úÖ HA_LLAT: {'Encontrada' if ha_token else 'N√£o encontrada'}")
    
    if not all([gemini_key, ha_url, ha_token]):
        print("‚ùå Credenciais necess√°rias n√£o encontradas")
        return False
    
    try:
        # 1. Configurar Cliente HA Real (Task 3)
        print("\nüì° CONFIGURANDO CLIENTE HA REAL (TASK 3)")
        ha_client = HomeAssistantClient(base_url=ha_url, access_token=ha_token)
        
        # Testar conectividade
        status = await ha_client.check_api_status()
        print(f"‚úÖ HA Status: {status.get('message', 'API running')}")
        
        # 2. Buscar entidades light e switch control√°veis
        print("\nüîç BUSCANDO ENTIDADES CONTROL√ÅVEIS...")
        all_states = await ha_client.get_all_states()
        
        # Filtrar apenas lights e switches com estados v√°lidos
        controllable_entities = []
        for entity in all_states:
            if (entity.entity_id.startswith(('light.', 'switch.')) and 
                entity.state in ['on', 'off'] and
                'cozinha' in entity.entity_id.lower()):
                controllable_entities.append(entity)
        
        print(f"‚úÖ Encontradas {len(controllable_entities)} entidades control√°veis da cozinha:")
        for entity in controllable_entities[:5]:
            friendly_name = entity.attributes.get('friendly_name', entity.entity_id)
            print(f"   ‚Ä¢ {entity.entity_id} ({entity.state}) - {friendly_name}")
        
        if not controllable_entities:
            print("‚ö†Ô∏è Nenhuma entidade control√°vel da cozinha encontrada")
            # Tentar com qualquer light/switch
            for entity in all_states:
                if (entity.entity_id.startswith(('light.', 'switch.')) and 
                    entity.state in ['on', 'off']):
                    controllable_entities.append(entity)
                    if len(controllable_entities) >= 3:
                        break
            
            print(f"‚úÖ Usando {len(controllable_entities)} entidades control√°veis gen√©ricas:")
            for entity in controllable_entities:
                friendly_name = entity.attributes.get('friendly_name', entity.entity_id)
                print(f"   ‚Ä¢ {entity.entity_id} ({entity.state}) - {friendly_name}")
        
        if not controllable_entities:
            print("‚ùå Nenhuma entidade control√°vel encontrada")
            return False
        
        # 3. Configurar Function Handler
        print("\n‚öôÔ∏è CONFIGURANDO FUNCTION HANDLER")
        function_handler = HomeAssistantFunctionHandler(ha_client)
        print(f"‚úÖ Handler configurado com {len(function_handler.get_supported_functions())} fun√ß√µes")
        
        # 4. Configurar Cliente Gemini Live (Task 4)
        print("\nü§ñ CONFIGURANDO GEMINI LIVE CLIENT (TASK 4)")
        gemini_client = GeminiLiveClient(api_key=gemini_key)
        
        # 5. Conectar √† Live API
        print("üîó Conectando √† Live API...")
        
        # Usar o m√©todo correto para conectar
        connected = await gemini_client.connect()
        if not connected:
            print("‚ùå Falha ao conectar √† Live API")
            return False
            
        print("‚úÖ Conectado √† Live API")
        
        try:
            # 6. Testar com entidade real - priorizar switch.cozinha
            test_entity = None
            
            # Buscar especificamente switch.cozinha
            for entity in controllable_entities:
                if entity.entity_id == "switch.cozinha":
                    test_entity = entity
                    break
            
            # Se n√£o encontrar switch.cozinha, usar a primeira dispon√≠vel
            if not test_entity:
                test_entity = controllable_entities[0]
            
            entity_id = test_entity.entity_id
            current_state = test_entity.state
            friendly_name = test_entity.attributes.get('friendly_name', entity_id)
            domain = entity_id.split('.')[0]
            
            print(f"\nüéØ TESTANDO COM ENTIDADE REAL:")
            print(f"   Entity ID: {entity_id}")
            print(f"   Nome: {friendly_name}")
            print(f"   Estado atual: {current_state}")
            print(f"   Dom√≠nio: {domain}")
            
            # Determinar comando baseado no estado atual
            if current_state == "on":
                action = "Desligue"
                expected_call = "turn_off"
            else:
                action = "Ligue"
                expected_call = "turn_on"
            
            command = f"{action} {friendly_name}"
            print(f"\nüì¢ COMANDO: '{command}'")
            
            # 7. Enviar comando via Live API
            print("üì§ Enviando comando...")
            sent = await gemini_client.send_text_input(command)
            if not sent:
                print("‚ùå Falha ao enviar comando")
                return False
            print("‚úÖ Comando enviado")
            
            # 8. Aguardar respostas
            print("üéß Aguardando respostas...")
            response_count = 0
            function_call_found = False
            
            async for response in gemini_client.receive_responses():
                response_count += 1
                
                response_type = response.get('type', 'unknown')
                print(f"üì® Resposta {response_count}: {response_type}")
                
                if response_type == 'function_call':
                    print("üîß Function call detectado!")
                    function_calls = response.get('data', {}).get('function_calls', [])
                    
                    for fc in function_calls:
                        function_name = fc.get("name")
                        args = fc.get("args", {})
                        print(f"   üìã Fun√ß√£o: {function_name}")
                        print(f"   üìã Args: {args}")
                        
                        # Executar function call com cliente HA real
                        try:
                            # Usar function handler para execu√ß√£o correta
                            result = await function_handler.handle_function_call({
                                "name": function_name,
                                "args": args
                            })
                            
                            if result.get('success'):
                                print(f"   ‚úÖ Executado com sucesso: {result.get('message', 'OK')}")
                                if 'result' in result:
                                    details = result['result']
                                    if isinstance(details, dict) and 'entity_id' in details:
                                        print(f"   üìä Entidade: {details['entity_id']}")
                                        print(f"   üìä A√ß√£o: {details.get('action', 'N/A')}")
                                function_call_found = True
                            else:
                                print(f"   ‚ö†Ô∏è Resultado: {result.get('message', 'Erro desconhecido')}")
                                
                        except Exception as e:
                            print(f"   ‚ùå Erro ao executar function call: {e}")
                
                elif response_type == 'audio':
                    audio_size = len(response.get("data", b""))
                    print(f"üéµ √Åudio recebido: {audio_size} bytes")
                
                elif response_type == 'text':
                    text = response.get("data", "")
                    if text:
                        print(f"üí¨ Texto recebido: {text[:100]}...")
                
                # Limitar respostas
                if response_count >= 10:
                    break
            
            # 9. Verificar estado final
            print("\nüîç Verificando estado final...")
            try:
                final_state = await ha_client.get_entity_state(entity_id)
                print(f"‚úÖ Estado final de {entity_id}: {final_state.state}")
                
                if final_state.state != current_state:
                    print("üéâ Estado mudou! Function call funcionou!")
                else:
                    print("‚ö†Ô∏è Estado n√£o mudou")
                    
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao verificar estado final: {e}")
            
            if function_call_found:
                print("‚úÖ Function call executado com sucesso!")
            else:
                print("‚ö†Ô∏è Nenhum function call detectado")
        
        finally:
            # Cleanup da sess√£o
            await gemini_client.disconnect()
        
        print("\n‚úÖ Teste conclu√≠do!")
        return True
        
    except Exception as e:
        print(f"‚ùå Erro no teste: {e}")
        import traceback
        traceback.print_exc()
        return False

async def main():
    print("üß™ TESTE DE INTEGRA√á√ÉO COM CLIENTES REAIS")
    print("=" * 70)
    
    success = await test_real_clients()
    
    print("\n" + "=" * 70)
    if success:
        print("üéâ INTEGRA√á√ÉO COM CLIENTES REAIS FUNCIONANDO!")
        print("‚úÖ Task 4 (GeminiLiveClient) operacional")
        print("‚úÖ Task 3 (HomeAssistantClient) operacional")
        print("‚úÖ Function calling integrado")
        print("‚úÖ Entidades reais do HA controladas")
    else:
        print("‚ö†Ô∏è Problemas detectados na integra√ß√£o")
    
    print("=" * 70)

if __name__ == "__main__":
    asyncio.run(main()) 